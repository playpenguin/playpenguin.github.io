<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>PlayPenguin.Tech-花花企鹅.技术 - dangbinghoo</title><link>/</link><description></description><lastBuildDate>Thu, 11 May 2017 22:36:00 +0800</lastBuildDate><item><title>ArchLinux 编译Anroid5 lollipop 错误解决</title><link>/archlinux-bian-yi-anroid5-lollipop-cuo-wu-jie-jue.html</link><description>&lt;div class="section" id="python"&gt;
&lt;h2&gt;错误1，python工具出错&lt;/h2&gt;
&lt;p&gt;错误情况如下：&lt;/p&gt;
&lt;pre class="code sh literal-block"&gt;
&lt;span class="o"&gt;============================================&lt;/span&gt;
File &lt;span class="s2"&gt;&amp;quot;build/tools/findleaves.py&amp;quot;&lt;/span&gt;, line &lt;span class="m"&gt;95&lt;/span&gt;
    print r
        ^
SyntaxError: Missing parentheses in call to &lt;span class="s1"&gt;'print'&lt;/span&gt;
File &lt;span class="s2"&gt;&amp;quot;build/tools/findleaves.py&amp;quot;&lt;/span&gt;, line &lt;span class="m"&gt;95&lt;/span&gt;
    print r
        ^
SyntaxError: Missing parentheses in call to &lt;span class="s1"&gt;'print'&lt;/span&gt;
File &lt;span class="s2"&gt;&amp;quot;build/tools/diff_package_overlays.py&amp;quot;&lt;/span&gt;, line &lt;span class="m"&gt;88&lt;/span&gt;
    print r
        ^
SyntaxError: Missing parentheses in call to …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Thu, 11 May 2017 22:36:00 +0800</pubDate><guid isPermaLink="false">tag:None,2017-05-11:/archlinux-bian-yi-anroid5-lollipop-cuo-wu-jie-jue.html</guid><category>android</category></item><item><title>小众又新颖的GUI</title><link>/xiao-zhong-you-xin-ying-de-gui.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2&gt;小众的新GUI框架记录&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;ugfx, C语言 STM32等MCU可使用的嵌入式GUI，商业级但免费无任何版权限制，可为创客，商业等任何用途。且包含一个The µGFX-Studio GUI构建程序可用。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;网址： &lt;a class="reference external" href="http://ugfx.io/"&gt;http://ugfx.io/&lt;/a&gt;
下载连接 &lt;a class="reference external" href="https://community.ugfx.io/index.php?/files/"&gt;https://community.ugfx.io/index.php?/files/&lt;/a&gt;&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;ilixi 基于DFB的C++嵌入式Linux平台GUI，完全开源 &lt;a class="reference external" href="http://www.ilixi.org/"&gt;http://www.ilixi.org/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于DirectFB,libsigc++等平台组件构建，看官网有个行车电脑的ui demo，API粗看了下跟WxWidget比较接近，从类列表看，3D等支持都是有的。支持buildroot构建工具，支持yocto，挺不错，值得尝试。&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;libui， C语言的桌面跨平台，本地UI风格的库，居然拥有10多种语言的binding了。&lt;a class="reference external" href="https://github.com/andlabs/libui"&gt;https://github.com/andlabs …&lt;/a&gt;&lt;/li&gt;&lt;/ol&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Thu, 08 Dec 2016 14:18:00 +0800</pubDate><guid isPermaLink="false">tag:None,2016-12-08:/xiao-zhong-you-xin-ying-de-gui.html</guid><category>GUI</category></item><item><title>安卓内核编译错误 kernel/timeconst.h defined(@val)</title><link>/an-zhuo-nei-he-bian-yi-cuo-wu-kerneltimeconsth-definedval.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2&gt;错误情况&lt;/h2&gt;
&lt;p&gt;今天编译安卓内核出现错误，&lt;/p&gt;
&lt;pre class="code sh literal-block"&gt;
$ ./mk -k
&lt;span class="c1"&gt;#
# configuration written to .config
#
&lt;/span&gt;scripts/kconfig/conf --silentoldconfig Kconfig
  CHK     include/linux/version.h
  CHK     include/generated/utsrelease.h
make&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;: &lt;span class="s1"&gt;'include/generated/mach-types.h'&lt;/span&gt; is up to date.
  CALL    scripts/checksyscalls.sh
  CHK     include/generated/compile.h
  TIMEC   kernel/timeconst.h
Can&lt;span class="s1"&gt;'t use '&lt;/span&gt;defined …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Sun, 22 May 2016 22:12:00 +0800</pubDate><guid isPermaLink="false">tag:None,2016-05-22:/an-zhuo-nei-he-bian-yi-cuo-wu-kerneltimeconsth-definedval.html</guid><category>android</category></item><item><title>关于ｃ语言位域的字节对齐问题</title><link>/guan-yu-cyu-yan-wei-yu-de-zi-jie-dui-qi-wen-ti.html</link><description>&lt;p&gt;最近在STM32F4上面进行嵌入式开发，需要做通讯，报文规定的字段并不以字节为最小单位，好多2,3位的长度元素
对于C语言，我们一般用位域来解决。&lt;/p&gt;
&lt;p&gt;可是，C教科书上给我们讲的位域不占用很多空间的前提没有讲述清楚，经查证，默认情况下C语言并没有规定统一
的字节对齐策略，导致用sizeof计算结构大小的时候结果在不同的平台上结果五花八门。下面代码的结构体，按理是
4个字节，结果默认情况下gcc计算结果为6。&lt;/p&gt;
&lt;dl class="docutils"&gt;
&lt;dt&gt;网络资料显示需要对结构体加pack属性， 这下GCC是对了，但是在win平台下面的MinGW结构居然是5&lt;/dt&gt;
&lt;dd&gt;???&lt;/dd&gt;
&lt;/dl&gt;
&lt;p&gt;玩我呢？ 后面搜索MinGW 位域对齐问题，发现MinGW并不像我想象的就是GCC，跟linux平台和cygwin并不完全相同，
至少这个地方表现跟VC++平台一致。&lt;/p&gt;
&lt;p&gt;好了，用pragma来指定按字节对齐的方式，按1字节对齐，这样位域才能正确。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;QCoreApplication&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdint.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;
&lt;span class="cp"&gt;#if defined WIN32 || defined _WIN64 || defined WINNT
&lt;/span&gt;    &lt;span class="cp"&gt;#pragma pack(push,1)
#endif
&lt;/span&gt;
&lt;span class="k"&gt;struct …&lt;/span&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Fri, 20 May 2016 14:04:00 +0800</pubDate><guid isPermaLink="false">tag:None,2016-05-20:/guan-yu-cyu-yan-wei-yu-de-zi-jie-dui-qi-wen-ti.html</guid><category>bitfield</category><category>位域</category><category>C</category><category>GCC</category></item><item><title>关于ｃ语言const修饰符对指针变量的修饰问题</title><link>/guan-yu-cyu-yan-constxiu-shi-fu-dui-zhi-zhen-bian-liang-de-xiu-shi-wen-ti.html</link><description>&lt;p&gt;在看同事的jni幻灯片的时候，看到了const 指针，就顺便聊了下，一直都觉得 带 const 修饰符的都应该
在声明的时候赋值，声明之后，再赋值是不过语法检查的。&lt;/p&gt;
&lt;p&gt;结果发现，对于指针来说，情况并不是我想的那样。&lt;/p&gt;
&lt;p&gt;对于char *来说，const 未修饰　变量名称时候，　赋值都是在可以后面随意改动的，也就是指针可以
重新任意赋值，但是赋值后的内存区域是不能修改的，但是若　const 是在修饰　变量名称，那么跟 普通类型变量都一样，
需要声明的时候赋值，否则，根本过不了语法检查。&lt;/p&gt;
&lt;p&gt;代码如下：&lt;/p&gt;
&lt;pre class="code c literal-block"&gt;
&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;lt;stdio.h&amp;gt;&lt;/span&gt;&lt;span class="cp"&gt;
&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xxxxxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt;  &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a1&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;xxxxxx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;1111111 …&lt;/span&gt;&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Fri, 03 Apr 2015 09:40:00 +0800</pubDate><guid isPermaLink="false">tag:None,2015-04-03:/guan-yu-cyu-yan-constxiu-shi-fu-dui-zhi-zhen-bian-liang-de-xiu-shi-wen-ti.html</guid></item><item><title>人， 理想， 现实</title><link>/ren-li-xiang-xian-shi.html</link><description>&lt;p&gt;对，这个话题看起来挺大的，但是我先声明下，我只是把自己的心里活动胡乱的摆出来而已。&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;转眼间，或者无意之中，自己已经长大了，对，应该可以算是长大了吧。窗外是呼呼的大风，有没么那么凌咧&lt;/div&gt;
&lt;div class="line"&gt;我并不清楚， 但却让我想起来了自己幼时。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;生活给我的影像是现实除了绿色的树林，湛蓝湛蓝的天以及数不清的繁星点点之外， 你还会遇到一个没有办法&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;的事情，对， 的确是这么回事，还是会很清楚的记得冬天快到年关的寒冷气息，很独特的味道，你知道风里会&lt;/div&gt;
&lt;div class="line"&gt;闻到年就快要到了。 嗯，我的确很向往糖果，瓜子，还有几乎没怎么见过的花生，桔子是很少问到的那种味道，&lt;/div&gt;
&lt;div class="line"&gt;虽然我对苹果的味道非常熟悉。你觉得那会很快乐么？ 我不知道，其实当时可能也不知道， 就几岁大点，只知道&lt;/div&gt;
&lt;div class="line"&gt;刚刚吃过了好一阵子讨厌的玉米混白面的面条了，只知道这种风意味着我可以闻到象喷喷的肉了吧，虽然不会一次&lt;/div&gt;
&lt;div class="line"&gt;吃非常的一大口，对， 你给我吃我也吃不了多少的。&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line"&gt;类似的感觉小时候应该很多吧， 呵呵，现在看来，很多人（包括身边的一堆人吧应该）会说，不是吧？ 有那么恼火？&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;呵呵，摇摇头笑笑便是 …&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 02 Jan 2013 07:40:00 +0800</pubDate><guid isPermaLink="false">tag:None,2013-01-02:/ren-li-xiang-xian-shi.html</guid></item><item><title>关于 C语言 里的 反射或者内省 的讨论</title><link>/guan-yu-cyu-yan-li-de-fan-she-huo-zhe-nei-sheng-de-tao-lun.html</link><description>&lt;p&gt;在语言里面， 根据class名字能够知道其成员的 功能叫做
内省c语言有没有这个功能.&lt;/p&gt;
&lt;p&gt;可以想到的办法是
通过宏，你在定义一个结构体的时候，同时生成了一个数据结构存放了这个class的成员名称，
同时， 得到成员的类型， 比如&amp;nbsp; struct {int a, float b};&lt;/p&gt;
&lt;p&gt;通过例子里面的宏可以得到&amp;nbsp; int a, float b, 这样的字符串的&lt;/p&gt;
&lt;p&gt;这个其实已经解决了上次你做 sql数据库函数时想要的功能&lt;/p&gt;
&lt;p&gt;对了&amp;nbsp; 今天开会研究nvram的意思就是以后我就不用写那个数据库的东西了？&lt;/p&gt;
&lt;p&gt;如果 再得到成员列表字串的时候把类型分立出来， 然后你可以用 &amp;quot;int&amp;quot;,
sizeof(int); &amp;quot;int&amp;quot;, sizeof(float); 这样的东西再做映射，
然后得到一个结构体类型的时候， 即便只有一个指向
class的指针，我们也有办法 把里面的成员一个一个取出来&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;这样， 对于数据库这样，你每次存的数据结构不同，但是query，什么的这些操作相同的这些操作，完全可以只写一个组函数方法就够了，而不用每&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;基本上可以达到 动态语言里面的 …&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 18 Dec 2012 12:28:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-12-18:/guan-yu-cyu-yan-li-de-fan-she-huo-zhe-nei-sheng-de-tao-lun.html</guid></item><item><title>学习unix路之愚见</title><link>/xue-xi-unixlu-zhi-yu-jian.html</link><description>&lt;div class="section" id="id1"&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;这段时间公司安排带领新人，
加上公司上层软件开发者的一些做事方法和思想我不是很赞同，
深感团队里人的重要性， 以前只是觉得技术和人都不大是问题，
可能机遇才是最难的事情， 但是现在看来，天时地利人和中最怕的是人和了，
一个团队做一件产品，两三年之后还拿不出东西来，做出来的东西如同大学的课程设计，只是一些能工作的代码的组合，界面使用上出现的逻辑以及错误提示达到了令所有常人难以理解的地步，以前真没有这种体会，所以才深感可怕。
这里我并不想对代码层次， 面向对象， 抽象，
以及做C的人根本不懂面向对象这些话题进行口舌，只是结合自己的学习路程，
从单片机硬件到单片机软件，C语言的编程，再到嵌入式linux系统的理解（bootloader到内核以及shell和应用），和python和cpp这样的语言的使用感受来说下我的思维观点：
因为团队很多人并不觉得软件开发都是一回事这种观点，
抽象或者说人的整个做事情思维方式差异太大。&lt;/p&gt;
&lt;p&gt;以下是我对新人的学习建议，这里摘录出来，其中基本也是我的思路和思维方式，其实个人愚见：
你见的多了，自然觉得都是一个道理了，大道至简，简单就是美，联系实际生活人的认知和解决问题的方法是如此之统一和简单，
要不然怎么会有哲学的产生？&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;怎么走unix之路？&lt;/h2&gt;
&lt;p&gt;作为unix/linux程序员（有可能被逼的，但是已经是了），
并且作为嵌入式程序员，基本的要求是C语言要掌握，并且能够很轻松的给人说明白什么是指针，什么是一板一眼的做事情（或者写程序的方法），面向对象是一个
很好的方法，不过面向对象的本质很少有人能够真正明白 …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 27 Nov 2012 03:03:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-11-27:/xue-xi-unixlu-zhi-yu-jian.html</guid></item><item><title>其实自己原本就是个“无脑”的程序员而已！--- 溢出 与 “环”</title><link>/qi-shi-zi-ji-yuan-ben-jiu-shi-ge-wu-nao-de-cheng-xu-yuan-er-yi-yi-chu-yu-huan.html</link><description>&lt;p&gt;记得前两天写东西的时候还遇到一个问题，这个问题大家很熟悉，
当然解决方法也很显然：&lt;/p&gt;
&lt;p&gt;坐标需要从0-256直接循环移动， 根据常理，很容易写出来这种代码&lt;/p&gt;
&lt;pre class="code c++ literal-block"&gt;
&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;//xxxxxxxxx
&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;256&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;对，对啊，很显然嘛，不这么做怎么做，不过当时也想过用循环链表， 这样，就永远处于一个圈里了，转就是了，后面一想，就这么个东西，&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;劳架链表太不好了，说不定后面来看就看不懂了，还会立马给句“SB！”&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;今天有幸看到一位CSDN大牛的blog，看到了&amp;nbsp;&lt;cite&gt;另一个视角解读计算机编码-补码编码&lt;/cite&gt; 一文， 文中很犀利的将我之前也觉得很头疼恼火的&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;补码解释的淋漓尽致，顿时想起来，哎，亏我还是个学数学的（纯属意外事故哈！），当时老师貌似说过 **群环域**的概念 ， 那上面&lt;/div&gt;
&lt;div class="line"&gt;这个东东不就是可以用位掩码来搞定嘛，就可以不用if else语句了嘛， 所以&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;-----&amp;gt;&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1. 首先， 自己大多数时候是个很 …&lt;/div&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 22 Aug 2012 09:11:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-08-22:/qi-shi-zi-ji-yuan-ben-jiu-shi-ge-wu-nao-de-cheng-xu-yuan-er-yi-yi-chu-yu-huan.html</guid></item><item><title>linux flash插件等程序声音不正常的原因： 笔记本多个声卡， 需要配置</title><link>/linux-flashcha-jian-deng-cheng-xu-sheng-yin-bu-zheng-chang-de-yuan-yin-bi-ji-ben-duo-ge-sheng-qia-xu-yao-pei-zhi.html</link><description>&lt;p&gt;前段实际系统是Arch linux，
当时什么程序都能放出声音来就是flash不行，一直无声状态， 始终没有搞定。&lt;/p&gt;
&lt;p&gt;这几天因为做嵌入式的原因，系统换成了Funtoo， 个人感觉就是改进了Gentoo 的
emerge --sync 吧， 其他的还不怎么明显， 也没体会到，感觉根Gentoo无异了，
不过系统装起来， 声音还是不正常， 播放mplayer说&lt;/p&gt;
&lt;p&gt;alsa-lib: pcm_dmix.c:1018:(snd_pcm_dmix_open) unable to open slave&lt;/p&gt;
&lt;p&gt;Google之发现是因为系统多个声卡， 没有配置的情况下会选择0,
alsamixer里面我的声卡也是两个， 第一个是什么hdmi的声卡， 哎，
感觉无奈，这个东东有用么， 不过还是自己水平低，
真正的声卡处于第二个位置， 突然想到这也是flash无声的缘故了吧， 随即编辑
.asoundrc 或者 /etc/asound.conf&lt;/p&gt;
&lt;pre class="literal-block"&gt;
pcm.!default {
    type hw
    card 1
}

ctl …&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Sun, 17 Jun 2012 13:00:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-06-17:/linux-flashcha-jian-deng-cheng-xu-sheng-yin-bu-zheng-chang-de-yuan-yin-bi-ji-ben-duo-ge-sheng-qia-xu-yao-pei-zhi.html</guid><category>asound.rc</category></item><item><title>使用ostinato做网络开发分析辅助工具</title><link>/shi-yong-ostinatozuo-wang-luo-kai-fa-fen-xi-fu-zhu-gong-ju.html</link><description>&lt;p&gt;最近参与公司一个项目, 需要在L2工作, 封包是经常的事情,之前一直用N2X,
需要排队, 后面搜索网络发现了ostinato工具， 虽然还在成长中,
但是已经非常强大够用了.&lt;/p&gt;
&lt;p&gt;特淘宝淘了个双口的千兆网卡, 拿回来装起, 先跑server drone程序,
然后开ostinato客户端, 计算机上的eth0,1,2均认的出来,
然后drone跑对了之后就port group可用了, 点击eth,
新建stream里面就可以选择L2, Vlan等选项, 非常强大，
另外发现intel的网卡芯片才支持vlan, 可以抓到带vlan标签的包,
正好淘的网卡是intel的服务器专用卡, 不错!,&lt;/p&gt;
&lt;p&gt;这里记下, 有用的同学可以参考下.&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 24 Apr 2012 06:46:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-04-24:/shi-yong-ostinatozuo-wang-luo-kai-fa-fen-xi-fu-zhu-gong-ju.html</guid><category>ostinato</category></item><item><title>acer aspire 4560G A6 apu notebook arch linux installation tips</title><link>/acer-aspire-4560g-a6-apu-notebook-arch-linux-installation-tips.html</link><description>&lt;p&gt;arch linux or gentoo linux installtion on Acer aspire 4560G will always
have troubles.&lt;/p&gt;
&lt;div class="section" id="the-video-driver-just-note"&gt;
&lt;h2&gt;the video driver. JUST &lt;strong&gt;NOTE&lt;/strong&gt;&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;amd catalyst driver will not works at all, I tired 1 year before, it
failed. and failed again today.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, you only need the opensource driver xf86-video-ati and use radeon
only …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 18 Apr 2012 15:54:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-04-18:/acer-aspire-4560g-a6-apu-notebook-arch-linux-installation-tips.html</guid><category>4560g</category><category>acer</category><category>Linux</category></item><item><title>如何恢复mysql inno db 损毁的数据库表内容 ?</title><link>/ru-he-hui-fu-mysql-inno-db-sun-hui-de-shu-ju-ku-biao-nei-rong.html</link><description>&lt;p&gt;一次机器的强制关机,导致了服务器mysql数据库启动失败,
说是数据库因为关机问题,数据写入不正常, 无法启动,
使用mysql的数据库恢复功能没能成功&lt;/p&gt;
&lt;p&gt;因为自己当时不知道数据库自己恢复的条件,只拷贝备份了数据库目录,
并没有备份idb和idb的log1,log2两个文件,所以自动恢复没法进行,基本上是数据&lt;/p&gt;
&lt;p&gt;已经丢失了&lt;/p&gt;
&lt;p&gt;网上去搜索发现有个恢复工具, 开源的 就拿试试, 果然最终还是解救到了数据.&lt;/p&gt;
&lt;p&gt;基本思路是, inno db引擎的数据库文件是 frm放 表项索引,
idb里面是表的具体内容, 只要idb文件在, 一般都是可以恢复的&lt;/p&gt;
&lt;p&gt;步骤如下:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;ol class="first arabic"&gt;
&lt;li&gt;使用工具 将idb文件分割得到很多page文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol class="first arabic" start="2"&gt;
&lt;li&gt;然后page文件全部cat到一个大文件&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;3. 找到你的表的结构: 我这里因为是服务器还在,
可以从原来正确的数据库里面读取到表的结构, 就是知道表当时是如何创建的&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;,使用 show table create &amp;lt;tablename&amp;gt;; sql 命令 就可以得到.&lt;/p&gt;
&lt;p&gt;这里工具里面有个脚本, 配置上你的参数, 叫自己去读,然后会生成一个头文件,
这个下面需要用来编译提取这个表用的解析器.&lt;/p&gt;
&lt;p&gt;&lt;em&gt;但是我的情况是&lt;/em&gt;数据库新建的表没有使用innodb格式了,所以需要将那个脚本里面的判断是不是innodb的语句注释 …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Sat, 31 Mar 2012 09:01:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-03-31:/ru-he-hui-fu-mysql-inno-db-sun-hui-de-shu-ju-ku-biao-nei-rong.html</guid></item><item><title>学习-资源</title><link>/xue-xi-zi-yuan.html</link><description>&lt;div class="section" id="linux"&gt;
&lt;h2&gt;Linux下的工作&lt;/h2&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;IDE&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;python -- eric&lt;/p&gt;
&lt;p&gt;perl&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; -- padre&lt;/p&gt;
&lt;p&gt;cpp/c,&amp;nbsp; -- codeblocks, Eclips CDT, codelite, anjuta, Geany, medit as
IDE, gedit with plugins.&lt;/p&gt;
&lt;p&gt;C#&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp; &amp;nbsp; -- mono develop&lt;/p&gt;
&lt;p&gt;exVim&amp;nbsp;&amp;nbsp; -- Vim IDE&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;Libs&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;glib for c (unix, mingw).&lt;/p&gt;
&lt;p&gt;libevent : event driven software desgin lib for C/C++&lt;/p&gt;
&lt;p&gt;libsig++: event lib for C++&lt;/p&gt;
&lt;ol class="arabic simple" start="3"&gt;
&lt;li&gt;debug&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;DDD/Nemiver/Kdbg …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 14 Mar 2012 08:24:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-03-14:/xue-xi-zi-yuan.html</guid></item><item><title>MinGW/Codelite 如何生成正确的dll文件</title><link>/mingwcodelite-ru-he-sheng-cheng-zheng-que-de-dllwen-jian.html</link><description>&lt;p&gt;dll文件里面包括了函数的实现二进制代码段，
在linker输出的时候，通常Cpp会对函数改名，所以名为writestr的函数可能在dll里面表示为writestr&amp;#64;0
这样的名称，所以在输出dll的时候需要使用def文件来处理这些输出的问题&lt;/p&gt;
&lt;p&gt;下面是def文件示例&lt;/p&gt;
&lt;p&gt;LIBRARY example&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;EXPORTS&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;cpystr&amp;#64;0 &amp;#64;1&lt;/div&gt;
&lt;div class="line"&gt;explong&amp;#64;0 &amp;#64;2&lt;/div&gt;
&lt;div class="line"&gt;writestr&amp;#64;4 &amp;#64;3&lt;/div&gt;
&lt;div class="line"&gt;cpystr=cpystr&amp;#64;0&lt;/div&gt;
&lt;div class="line"&gt;explong=explong&amp;#64;0&lt;/div&gt;
&lt;div class="line"&gt;writestr=writestr&amp;#64;4&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;使用=可以对函数名称做别名进行修正，在默认情况下mingw输出的so文件实际就是dll文件，只不过函数名称是加了序号的&lt;/p&gt;
&lt;p&gt;总结用codelite输出正确dll的方法是&lt;/p&gt;
&lt;p&gt;在链接参数里加 -Wl,--out-implib,libexp.a,--output-def,exp2.def&lt;/p&gt;
&lt;p&gt;这样编译器会自动输出一个当前编译出来的so文件的导出函数列表，当然是加了数字序号之类的，所以你需要更名，复制一份按上面的语法添加别名，然后存为exp.def文件&lt;/p&gt;
&lt;p&gt;这样postbuild里面再用这样的语句重新输出dll文件，g …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Sun, 04 Mar 2012 05:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-03-04:/mingwcodelite-ru-he-sheng-cheng-zheng-que-de-dllwen-jian.html</guid></item><item><title>seascope代码阅读器支持编辑补丁</title><link>/seascopedai-ma-yue-du-qi-zhi-chi-bian-ji-bu-ding.html</link><description>&lt;p&gt;&lt;a class="reference external" href="http://code.google.com/p/seascope/"&gt;Seascope&lt;/a&gt;
是一个pyQt写的代码阅读工具，在linux原来的kscope其实功能很强大，绝对可比source
Insight，不过，kde到4之后就没维护了，后来偶遇seascope，不过当时是0.3版本，代码显示的时候字体不能改变，文件也是只读，没法编辑，不过函数定义，引用等搜索功能确是完整的，但是下下来用了用不是很方便编辑就不了了之了。&lt;/p&gt;
&lt;p&gt;前两天同事又问linux下面代码阅读工具，就又去看了看，发现出0.4版本了，下载来看了下变化比较大，不过编辑功能还是没有啊，看了看是pyQt，正好自己还是想深入学习下python，那看看能不能自己改改呢
？
两天努力下来还真基本给实现了，支持一般的代码编辑器的编辑功能了，保存文件也基本可以工作了，不过可能有一些小bug
，patch邮件给了原作者，不过不知道作者会不会接受了。&lt;/p&gt;
&lt;p&gt;这里给出patch&lt;/p&gt;
&lt;pre class="literal-block"&gt;
diff -purN seascope-0.4/src/Seascope.py seascope-0.4-dbh/src/Seascope.py
--- seascope-0.4/src/Seascope.py&amp;nbsp;&amp;nbsp; &amp;nbsp;2011-12-15 …&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Sat, 18 Feb 2012 14:22:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-02-18:/seascopedai-ma-yue-du-qi-zhi-chi-bian-ji-bu-ding.html</guid><category>seascope</category></item><item><title>exVim 小修改，解决右键菜单问题</title><link>/exvim-xiao-xiu-gai-jie-jue-you-jian-cai-dan-wen-ti.html</link><description>&lt;p&gt;在安装了exVim插件之后，发现几个很不合我意的地方，exvim默认关闭折行line
wrap功能,理由是多窗口的时候Look
strange，我是不太受的了一行很长很长了，所以还是打开，另外exvim对xterm模式下设置了鼠标模式=a，这样在终端里居然没法右键菜单来复制了，对我来说这个有时候还是很不方便的，毕竟在窗口之间的复制粘贴快捷键不一定管用。&lt;/p&gt;
&lt;p&gt;修改vimrc_ex：&lt;/p&gt;
&lt;p&gt;注释掉&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;quot;set nowrap
&amp;quot;if &amp;amp;term =~ &amp;quot;xterm&amp;quot;
&amp;quot;    set mouse=a
&amp;quot;endif
&lt;/pre&gt;
&lt;p&gt;另外exvim工程模式下的一些目录没有隐藏，我修改了做了修改让其功能文件统一放到隐藏的目录下面，并且exvim的vimrc设置也比较乱，修改，让从vimrc调用vimrc_ex，然后其他的目录和文件统统进入.vim下面，比较清晰一致些。&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 14 Feb 2012 02:18:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-02-14:/exvim-xiao-xiu-gai-jie-jue-you-jian-cai-dan-wen-ti.html</guid><category>exvim</category><category>Linux</category></item><item><title>我的人生目标</title><link>/wo-de-ren-sheng-mu-biao.html</link><description>&lt;div class="section" id="id2"&gt;
&lt;h2&gt;&amp;nbsp;找个还不错的工作，有饭吃，工作茶余饭后，自己在书屋或者时髦点“车库”里做自己的一套自娱自乐的研究，短期阶段留一两样产品给世上，长期阶段留点自己的研究结果给世上，在某个小点上大家听过我的名字就行了！&lt;/h2&gt;
&lt;/div&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 07 Feb 2012 06:24:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-02-07:/wo-de-ren-sheng-mu-biao.html</guid><category>Life</category></item><item><title>mips嵌入式linux系统构建过程</title><link>/mipsqian-ru-shi-linuxxi-tong-gou-jian-guo-cheng.html</link><description>&lt;p&gt;mips平台的嵌入式linux构建，比较简明的步骤，包括nanoRC的使用，根文件系统的制作，不包括mips工具链的制作。&lt;/p&gt;
&lt;div class="section" id="mips"&gt;
&lt;h2&gt;&amp;nbsp;1. mips交叉编译环境搭建&lt;/h2&gt;
&lt;p&gt;编译环境需要选择mips-2007-01-21,从
&amp;quot;这里&amp;quot;:&lt;a class="reference external" href="ftp://ftp.denx.de/pub"&gt;ftp://ftp.denx.de/pub&lt;/a&gt;/eldk下载光盘iso,然后解压提取出整个环境,然后安装就可以了,安装指令:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
install -d /your/toochain/path
&lt;/pre&gt;
&lt;p&gt;然后设置path环境变量.&lt;/p&gt;
&lt;pre class="literal-block"&gt;
export PATH=/your/toochain/path/usr/bin:${PATH}
&lt;/pre&gt;
&lt;pre class="literal-block"&gt;
对于gentoo 系统,可以

&amp;nbsp; &amp;nbsp;  $ cat &amp;gt; /etc/env.d/50mipstoolchain &amp;lt;&amp;lt; &amp;quot;EOF&amp;quot;
&amp;nbsp; &amp;nbsp; &amp;nbsp; &amp;nbsp;PATH=&amp;quot;/media/workspace/tools/eldk-mips-x.x/usr/bin …&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 11 Jan 2012 08:18:00 +0800</pubDate><guid isPermaLink="false">tag:None,2012-01-11:/mipsqian-ru-shi-linuxxi-tong-gou-jian-guo-cheng.html</guid><category>embedded</category><category>Linux</category><category>mips</category></item><item><title>Think what programming (languages) really do ? &gt; translations.</title><link>/think-what-programming-languages-really-do-translations.html</link><description>&lt;p&gt;We write programs everyday, and then compile or &amp;quot;run&amp;quot; directly,
&lt;strong&gt;think what really programming doing&lt;/strong&gt; ?&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt; Translations.
&lt;/pre&gt;
&lt;p&gt;yes, a Cpp program might be 1st translated into C, and then &amp;nbsp;AS, and
then machine code. A shell script can be &amp;quot;run&amp;quot; directly, but it need
bash to translate. so, everything on computer …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 27 Dec 2011 01:53:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-12-27:/think-what-programming-languages-really-do-translations.html</guid><category>parrot</category><category>programming</category></item><item><title>[原创]OpenEmbedded 中文手册</title><link>/yuan-chuang-openembedded-zhong-wen-shou-ce.html</link><description>&lt;div&gt;&lt;p&gt;8.11 打包:定义包类及其内容&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;一个bitbake&amp;quot;配方&amp;quot;就是一组创建一个或者多个在目标设备上安装的包的命令集合.典型的包就是&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;.ipkg或者.deb包(尽管bitbake本身并没有跟任何特殊的包格式相关联).&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;默认情况下会自动生成一些包,这些包并没有包含任何&amp;quot;配方&amp;quot;作者要求的特定动作.上面的helloworld&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;例子的包输出信息就说明了这些:&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;[NOTE: package helloworld-0.1-r0: task do_package_write: started&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;NOTE: Not creating empty archive for helloworld-dbg-0.1-r0&lt;/p&gt;
&lt;/div&gt;&lt;div&gt;&lt;p&gt;Packaged contents of helloworld into
/home/lenehan/devel/oe/build/titan-glibc-25/tmp/deploy/ipk/sh4/helloworld_0.1-r0_sh4.ipk …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Thu, 22 Dec 2011 01:41:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-12-22:/yuan-chuang-openembedded-zhong-wen-shou-ce.html</guid><category>Linux</category><category>OE中文</category><category>OpenEmbedded</category></item><item><title>[原创]OpenEmbedded 中文手册-第一部分</title><link>/yuan-chuang-openembedded-zhong-wen-shou-ce-di-yi-bu-fen.html</link><description>&lt;div align="center"&gt;&lt;p&gt;声&amp;nbsp;&amp;nbsp; 明：&lt;/p&gt;
&lt;/div&gt;&lt;div style="text-align: justify;"&gt;&lt;p&gt;本文章为openembedded英文手册的中文翻译版。手册版权归OE所有。本文档只供技术和学习交流之用，不得用于商业用途，使用本文档如造成损失,译者一概不负任何责任。&lt;/p&gt;
&lt;/div&gt;&lt;p&gt;转载请注明出处和作者！&lt;/p&gt;
&lt;p&gt;作者: &lt;a class="reference external" href="mailto:dangbinghoo&amp;#64;gmail.com"&gt;dangbinghoo&amp;#64;gmail.com&lt;/a&gt;&lt;/p&gt;
&lt;div style="text-align: right;"&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;特此声明!&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;更新日志：&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2008年12月03日 改正笔误&lt;/div&gt;
&lt;div class="line"&gt;2008年12月21日 更新到8.11&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;2010年07月28日&amp;nbsp;更新到8.12&lt;/div&gt;
&lt;div class="line"&gt;&lt;br /&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class="line-block"&gt;
&lt;div class="line"&gt;第一章 .简介&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;本章内容&lt;/div&gt;
&lt;div class="line"&gt;*预览&lt;/div&gt;
&lt;div class="line"&gt;*历史回顾&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;1.1 预览&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;oe bitbake像所有的build工具一样（比如make，ant，jam）控制如何去构建系统并且解决构建依赖，但是&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line"&gt;不像那些功能单一的工程管理工具（比如make），bitbake不是基于把依赖写死了的makefile，而是&lt;/div&gt;
&lt;div class="line"&gt;收集和管理大量之间没有依赖关系的描述文件（这里我们称为包的配方），然后自动按照正确的顺序进行&lt;/div&gt;
&lt;div class="line"&gt;构建。（包的配方下文除非特殊说明都将简称为“配方”；oe都代表OpenEmbedded）&lt;/div&gt;
&lt;/div&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;更确切的说 …&lt;/div&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Thu, 22 Dec 2011 01:39:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-12-22:/yuan-chuang-openembedded-zhong-wen-shou-ce-di-yi-bu-fen.html</guid><category>Linux</category><category>OE中文</category><category>OpenEmbedded</category></item><item><title>再记轻量标记驱动的文档工具与系统</title><link>/zai-ji-qing-liang-biao-ji-qu-dong-de-wen-dang-gong-ju-yu-xi-tong.html</link><description>&lt;p&gt;经过一段时间的学习与查阅资料，发现 unix下面实现的各种 轻量标记
文档系统很多，而且格式花样， 在sytax上 有&lt;/p&gt;
&lt;div class="section" id="id2"&gt;
&lt;h2&gt;可选的轻量文档标记系统有：&lt;/h2&gt;
&lt;p&gt;Markdown(extra) ，&lt;a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/introduction.html"&gt;reStructuredText&lt;/a&gt;, txt2tags, textile, Asciidoc,
等等，发现在sytax风格上有相似，但是又不同，经典&amp;nbsp;Markdown
是不支持表格的，txt2tags
也不怎么完善(虽然我针对html和tex做了hack)，&lt;a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/introduction.html"&gt;reStructuredText&lt;/a&gt;&amp;nbsp;和&amp;nbsp;&amp;nbsp;textile
的
ruby实现版本比较完备但又简单，&amp;nbsp;Asciidoc是最复杂的也是最齐全的，基本上元素丰富程度接近与
Docbook 和&amp;nbsp;TeX 系统了，Asciidoc感觉是&amp;nbsp;Docbook的轻量标记版。&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="sytax"&gt;
&lt;h2&gt;以这些sytax为驱动的文档系统可以选择的有：&lt;/h2&gt;
&lt;p&gt;txt2tags: 输出各种格式，简单，缺点是txt2tags的syntax功能上还是稍显欠缺。&lt;/p&gt;
&lt;p&gt;pandoc:
以markdown为主syntax,但是由于&lt;strong&gt;支持几乎全部syntax&lt;/strong&gt;的各种格式的输入，所以，&amp;nbsp;&lt;a class="reference external" href="http://docutils.sourceforge.net/docs/ref/rst/introduction.html"&gt;reStructuredText&lt;/a&gt;&amp;nbsp;等各种都被比较好的支持 …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 21 Dec 2011 11:42:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-12-21:/zai-ji-qing-liang-biao-ji-qu-dong-de-wen-dang-gong-ju-yu-xi-tong.html</guid><category>markup</category><category>pdf</category><category>文档工具</category><category>标记</category></item><item><title>txt2tags 与 xelatex输出pdf</title><link>/txt2tags-yu-xelatexshu-chu-pdf.html</link><description>&lt;p&gt;txt2tags由于输出target比较多，支持pdf，html，docbook，redmine
wiki，所以基本被我“相中”。&lt;/p&gt;
&lt;p&gt;公司要求写个需求文档，就试着写了下，用自己的写的格式输出tex，再转换xelatex-ctex格式，就发现生成pdf没有问题了，编译完全通过，只不过为了pdf有更好的脸面：
支持标签目录，目录颜色，页眉页脚样式修正就做了个脚本对txt2tags输出的格式做了简单调整，现在一个make，html，pdf就ready了，哈哈！&lt;/p&gt;
&lt;p&gt;下面是我的tex输出心得：&lt;/p&gt;
&lt;p&gt;1.tex系统有N多实现，在windows上ctex不能配置就能工作，在linux上面要安装texlive-cjk相关，安装recommded，extra等包。&lt;/p&gt;
&lt;p&gt;gentoo系统有ebuild，相对简单，ubuntu貌似我现在用的11.10还没包上线(ubuntu
NB,但不专业了).&lt;/p&gt;
&lt;ol class="arabic simple" start="2"&gt;
&lt;li&gt;我用xelatex，tex文档开头得改成:&lt;/li&gt;
&lt;/ol&gt;
&lt;pre class="literal-block"&gt;
documentclass[UTF8,adobefonts,a4paper]{ctexart}
&lt;/pre&gt;
&lt;p&gt;%ctexart就是ctex article了，开始恼了半天。&lt;/p&gt;
&lt;p&gt;3.
adobefonts得有，网上下载的放进/usr …&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Mon, 12 Dec 2011 11:30:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-12-12:/txt2tags-yu-xelatexshu-chu-pdf.html</guid><category>ctex</category><category>pdf</category><category>txt2tags</category></item><item><title>各种用来写wiki和文档的light-weight markup 工具</title><link>/ge-chong-yong-lai-xie-wikihe-wen-dang-de-light-weight-markup-gong-ju.html</link><description>&lt;p&gt;&lt;em&gt;wordpress，redmine，wikipedia&lt;/em&gt;
等都支持使用一些标记语言来写wiki页面，其实这些东西都是一种
&lt;strong&gt;&amp;quot;Lightweight_markup_language &amp;quot;&lt;/strong&gt;
,搜索了下发现跟redmine使用的textile类似的东西包括: markdown,
markdown2(extra), txt2tags, AsciiDoc, texy!
,BBcode,Mediawiki等等，都有一个特点
：&lt;strong&gt;*就是使用纯文本标记来标记文档的格式标题等*&lt;/strong&gt;。&lt;/p&gt;
&lt;address&gt;&lt;p&gt;经过比较发现：&lt;/p&gt;
&lt;/address&gt;

 #.

    .. raw:: html

       &lt;address&gt;

    ***AsciiDoc**    最复杂，可以用来写
    文章，书本，与docbook转换比较好，功能上最解决与     docbook，有
    git         manual，Programming iOS 4
    这样的作品都是用它写的，查看其手册的确也很好很强大的感觉。*

    .. raw:: html

       &lt;/address&gt;

 #. **txt2tags**          输出格式多，未来可以支持 redmine wiki，
    wordpress，
 #. **markdown**
    用的最多，存在各种实现，c，python，perl等各种语言的版本 …</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Tue, 06 Dec 2011 16:58:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-12-06:/ge-chong-yong-lai-xie-wikihe-wen-dang-de-light-weight-markup-gong-ju.html</guid><category>markup</category><category>文档工具</category><category>标记</category></item><item><title>--host --build --target到底什么意思？</title><link>/-host-build-targetdao-di-shi-yao-yi-si.html</link><description>&lt;p&gt;老是在做交叉编译，其实有时候对这三个东西的理解并不是那么清楚&lt;/p&gt;
&lt;p&gt;从交叉工具链的情况来看，可以总结如下&lt;/p&gt;
&lt;p&gt;--build= 谁在这里编译？ 意思说你目前的编译动作在哪里跑的 ？
如果是编译一个arm工具链，虽然工具链为为arm弄的，但是构建工具链的时候是在主机上进行的。所以
--build=i686-pc-linux-gnu&lt;/p&gt;
&lt;p&gt;--host= 目前编译出来的程序在哪里跑 ？
所以工具链好了之后，给目标系统编译程序全部是设置host为arm的。&lt;/p&gt;
&lt;p&gt;--target=为谁编译程序，这在交叉编译的时候跟host一个意思，一般是guess的，而且configure
脚本会说是 =--host.&lt;/p&gt;
&lt;p&gt;通常我们编译复杂的情况就是交叉编译了，据说还有一种很复杂的情况，三个平台：&lt;/p&gt;
&lt;p&gt;比较，我现在在 i686机器上，想编译一个在
ppc上运行的交叉工具链，然后这个交叉工具链为arm生产程序，这个就算比较复杂了。&lt;/p&gt;
&lt;p&gt;应该是binutils，gcc，libc的时候这个三个--要很谨慎的设置了。&lt;/p&gt;
&lt;p&gt;可能是&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;--build=i686-pc-linux-gnu&lt;/li&gt;
&lt;li&gt;--host=ppc-xxx&lt;/li&gt;
&lt;li&gt;--target=arm-xxx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;没有实验过，可以改天实验下，学习下。&lt;/p&gt;
&lt;div class="section" id="id1"&gt;
&lt;h2&gt;续：三平台交叉编译实验&lt;/h2&gt;
&lt;p&gt;对binutils源码解压 …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Fri, 25 Nov 2011 16:04:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-11-25:/-host-build-targetdao-di-shi-yao-yi-si.html</guid><category>交叉编译</category></item><item><title>关于工具链的编译uclibc/gcc</title><link>/guan-yu-gong-ju-lian-de-bian-yi-uclibcgcc.html</link><description>&lt;p&gt;使用之前弄的脚本编译工具链其实还是比较轻松的，脚本也是比较稳定的，不过重点在于配置上，包括target名称的选择，uclibc的配置&lt;/p&gt;
&lt;p&gt;一直困扰的nfs挂载不正常的问题最终发现还是uclibc配置不对，另外，对于thread的支持，一般需要使用nptl，然后如果要用gdb的话，gdbserver的编译必须要在uclibc里面启用thread
debug，要不然会缺少东西：&lt;/p&gt;
&lt;blockquote&gt;
&lt;pre class="literal-block"&gt;
#error No uintptr_t available; your C library is too old.
&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;接着还会说thread_db.h 造成的某结构体的成员th不存在。&lt;/p&gt;
&lt;p&gt;新的uclibc
0.9.32编译时需要链接libgcc_eh库文件，这个库文件在static阶段是不编译的，如果要让编译，需要硬性打patch实现。&lt;/p&gt;
&lt;p&gt;这里贴一个正确的uclibc配置&lt;/p&gt;
&lt;pre class="literal-block"&gt;
#
# Automatically generated make config: don't edit
# Version: 0.9.32
# Wed Nov 23 14:53:07 …&lt;/pre&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 23 Nov 2011 15:12:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-11-23:/guan-yu-gong-ju-lian-de-bian-yi-uclibcgcc.html</guid><category>工具链</category></item><item><title>关于linux文件系统的sync,async, sync/fsync 命令</title><link>/guan-yu-linuxwen-jian-xi-tong-de-syncasync-syncfsync-ming-ling.html</link><description>&lt;p&gt;linux默认情况下几乎所有应用场合都是不会将文件立马保存入磁盘的，在嵌入式上也是同样的表现，如果mount时候加上sync选项就可以保证数据立马写入，但是这种会造成系统较多的写入磁盘，磁盘的寿命就不会太长了，如果是需要保存数据，可以显式调用命令sync来写入所有文件，或者fsync来保存某个文件。&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Fri, 18 Nov 2011 11:15:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-11-18:/guan-yu-linuxwen-jian-xi-tong-de-syncasync-syncfsync-ming-ling.html</guid><category>Linux</category><category>sync</category><category>文件系统</category></item><item><title>shell获取进程ID的方法： pidof | pgrep | ps-A+grep+awk</title><link>/shellhuo-qu-jin-cheng-idde-fang-fa-pidof-pgrep-ps-agrepawk.html</link><description>&lt;p&gt;shell获取进程ID的方法：&lt;/p&gt;
&lt;p&gt;我知道和实践过的有这么三种：&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&amp;nbsp;ps -A |grep &amp;quot;cmdname&amp;quot;| awk '{print $1}'&lt;/li&gt;
&lt;li&gt;&amp;nbsp;pidof &amp;quot;cmdname&amp;quot;&lt;/li&gt;
&lt;li&gt;&amp;nbsp;pgrep &amp;quot;cmdname&amp;quot;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这三种在bash和busybox ash里面的运行结果稍有不同，&lt;/p&gt;
&lt;p&gt;第一种完全相同，但是因为调用命令次数较多，性能上是不行的。&lt;/p&gt;
&lt;p&gt;第二种： pidof 只能获取程序的文件名匹配到的进程号，在ash中 比如 pidof
&amp;quot;usr/bin/telnetd&amp;quot; 和 pidof &amp;quot;telnetd&amp;quot;中结果不一样，
前一种结果为空，但是在bash中执行两者一样。&lt;/p&gt;
&lt;p&gt;第三种： pgrep跟1的效果相同，因为是单一命令，比第一种性能要好得多。&lt;/p&gt;
&lt;p&gt;所以nanoRC就改进为pgrep。&lt;/p&gt;
</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Fri, 18 Nov 2011 11:08:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-11-18:/shellhuo-qu-jin-cheng-idde-fang-fa-pidof-pgrep-ps-agrepawk.html</guid><category>pgrep</category><category>pidof</category><category>shell</category><category>进程ID</category></item><item><title>linux编程库libevent</title><link>/linuxbian-cheng-ku-libevent.html</link><description>&lt;div class="section" id="libevent-an-event-notification-library"&gt;
&lt;h2&gt;libevent – an event notification library&lt;/h2&gt;
&lt;p&gt;发现一个跨平台的event库：&lt;/p&gt;
&lt;p&gt;The &lt;em&gt;libevent&lt;/em&gt; API provides a mechanism to execute a callback function
when a specific event occurs on a file descriptor or after a timeout has
been reached. Furthermore, &lt;em&gt;libevent&lt;/em&gt; also support callbacks due to
&lt;strong&gt;signals&lt;/strong&gt; or regular &lt;strong&gt;timeouts&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Libevent additionally provides a sophisticated framework …&lt;/p&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">dangbinghoo</dc:creator><pubDate>Wed, 16 Nov 2011 11:27:00 +0800</pubDate><guid isPermaLink="false">tag:None,2011-11-16:/linuxbian-cheng-ku-libevent.html</guid><category>libevent</category><category>Linux</category></item></channel></rss>